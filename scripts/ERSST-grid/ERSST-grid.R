library(ncdf4)
library(raster)

#' Convert bounding box [0,360] longitudes to [-180, 180]
#'
#' Bounding boxes are 4 element vectors of [left, right, bottom, top]
#'
#' @export
#' @param x numeric bounding box vector, no check is done for being withing 0,360 range
#' @return numeric bounding box vector
to180BB <- function(x) {x[1:2] <- to180(x[1:2]) ; x}

#' Convert [-180,180] bounding box longitudes to [0,360]
#'
#' Bounding boxes are 4 element vectors of [left, right, bottom, top]
#'
#' @export
#' @param x numeric bounding box vector, no check is done for being withing 0,360 range
#' @return numeric bounding box vector
to360BB <- function(x) {x[1:2] <- to360(x[1:2]) ; x}

#' Convert [0,360] longitudes to [-180, 180]
#'
#' @export
#' @param x numeric vector, no check is done for being withing [0, 360] range
#' @return numeric vector
to180 <- function(x) {ix <- x > 180 ; x[ix] <- x[ix]-360; x}

#' Convert [-180,180] longitudes to [0, 360]
#'
#' @export
#' @param x numeric vector, no check is done for being within [0,3 60] range
#' @return numeric vector
to360 <- function(x) {ix <- x < 0 ; x[ix] <- x[ix]+ 360; x}

#' Retrieve navigation info for ERSST
#'
#' @param x character or ncdf4-class, if character it should be a URL.
#' @param bb 4 element numeric, bounding box [west, east, south, north]
#'        where south and west are negative
#' @param dates Date-class, sequence of one or more dates to retrieve
#' @param res numeric, 2 element resolution [res_x,res_y]
#' @param varname the name of the variable to extract
#' @return list of items needed to extract data
ERSST_nc_nav <- function(x,
  bb = to360BB(c(-88, -48, 24, 52)) ,
  dates = as.Date(c("2018-01-01", "2018-01-02", "2018-01-03","2018-01-04")),
  varname = 'sst',
  res = c(2.0, 2.0)){

  stopifnot(inherits(x, "ncdf4"))
  lat <- x$dim$lat$vals
  lon <- x$dim$lon$vals
  if (!(varname[1] %in% names(x$var))) stop("varname not known:", varname[1])
  if (length(res) == 1) res <- c(res[1],res[1])
  r2 <- res/2

  if (x$dim$time$len == 12){
    # type = 'ltm'
    idx = seq_len(12)
  } else {
    #type = 'month'
    time <- ncdf4::ncvar_get(x, "time") + as.Date("1800-01-01")
    idx <- findInterval(dates, time)
  }

  bb2 <- bb + c(-r2[1], r2[1], -r2[2], r2[2])
  iW <- which.min(abs(lon - bb2[1]))
  iE <- which.min(abs(lon - bb2[2]))
  iS <- which.min(abs(lat - bb2[3]))
  iN <- which.min(abs(lat - bb2[4]))
  list(bb = bb,
       res = res,
       start = c(iW, iN, idx[1]),
       count = c(iE- iW + 1, iS - iN + 1, length(idx)),
       ext = to180BB(c(lon[iW] - r2[1], lon[iE] + r2[1],
                       lat[iS] - r2[2], lat[iN] + r2[2])),
       crs = "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0",
       varname = varname)

}

#' Retrieve the URL for the specified type
#'
#' @param type character either 'month' or 'ltm'
#' @param base_url character the root url
#' @return charcater URL
ERSST_nc_url <- function(type = c("month", "ltm")[1],
  base_url = "https://www.esrl.noaa.gov/psd/thredds/dodsC/Datasets/noaa.ersst.v5"){

    fname <- switch(tolower(type[1]),
           "ltm" = "sst.mon.ltm.1981-2010.nc",
           "sst.mnmean.nc")
    file.path(base_url, fname)
}

#' Retrieve a stack of rasters by month
#'
#' @param x ncdf4 object (will be closed upon return)
#' @param nav list, as generated by ERSST_nc_nav
#' @return raster stack
ERSST_fetch <- function(x, nav){

  stopifnot(inherits(x, "ncdf4"))
  m <- ncdf4::ncvar_get(x,
                        varid = nav$varname,
                        start = nav$start,
                        count = nav$count)
  filenm <- x$filename
  ncdf4::nc_close(x)
  d <- dim(m)         # beware that if only one layer is requested
  n <- length(d)      # that we get an mxn matrix ratehr than mxnxl array
  if (n < 3){         # awkward but neccessary
    n <- 1
  } else {
    n <- d[n]
  }
  SS <- lapply(seq_len(n),
               function(i){
                 raster::raster(t(m[,,i]),
                                crs = nav$crs,
                                xmn = nav$ext[1],
                                xmx = nav$ext[2],
                                ymn = nav$ext[3],
                                ymx = nav$ext[4])
               })

  raster::stack(SS)
}

#' Retrieve a stack of ERSST grids for either monthly means or the long term mean.
#'
#' @param type character, either 'month' (default) or 'ltm' (long term mean')
#' @param bb numeric, 4 element vector of [west, east, south, north] boundaries,
#'        where west and south are negative.
#' @param varname character the name of the variable "sst" (default)
#' @param daterange 2 element character in YYYY-mm-dd format or Date day,
#'        inclusive start and end dates.  Ignored if type is set to 'ltm' in which
#'        case 12 months are downloaded.
#' @param outpath character or NA, optional output path to save rasters
#' @param overwrite logical, see \code{raster}
#' @param fmt character either 'raster' or 'GTiff' (default)
ERSST_get_grid <- function(type = c("month", "ltm")[1],
                           bb = c(-88, -48, 24, 52),
                           daterange = c('2018-01-01', '2018-04-01'),
                           outpath = NA,
                           fmt = c("raster", "GTiff")[2],
                           overwrite = TRUE){

  type <- tolower(type[1])
  ersst_url <- ERSST_nc_url(type = type)

  if (type == 'ltm'){
    dates <- seq.Date(from = as.Date("2018-01-01"),
                      to = as.Date("2018-12-01"),
                      by = "month")
  } else {
    if (!inherits(daterange, "Date")) daterange <- as.Date(daterange)
    dates <- seq(from = daterange[1], to = daterange[2], by = "month")
  }
  x <- ncdf4::nc_open(ersst_url)
  nav <- ERSST_nc_nav(x,
                      bb = to360BB(bb),
                      dates = dates)
  SS <- ERSST_fetch(x, nav)
  SS <- raster::setZ(SS, dates)
  if (type == 'ltm'){
    names(SS) <- format(dates, "%b")
  } else {
    names(SS) <- format(dates, "%b_%Y")
  }
  if (!is.na(outpath)){
    if (!dir.exists(outpath[1])){
      ok <- dir.create(outpath[1], recursive = TRUE, showWarnings = FALSE)
      if (!ok) stop("unable to create outpath:", outpath[1])
    }
    ext <- switch(tolower(fmt[1]),
                          'gtiff' = "tif",
                          'raster' = "grd")
    if (type == 'ltm'){
      ofile <- sprintf("%s-ltm.%s",format(dates, "%m"),ext)
    } else {
      ofile <- sprintf("%s.%s",format(dates, "%Y-%m"),ext)
    }
    for (i in seq_along(raster::nlayers(SS))){
      raster::writeRaster(SS[[i]], file.path(outpath, ofile[i]),
                          format = fmt,
                          overwrite = overwrite)
    }
  }

  SS
}
